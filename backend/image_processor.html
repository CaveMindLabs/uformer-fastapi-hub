<!-- noctura-uformer/backend/image_processor.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NocturaVision - Image File Processor</title>
    <style>
        html, body { height: 100vh; margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #282c34; color: white; display: flex; flex-direction: column; }

        /* --- Consistent Header --- */
        header { background-color: #20232a; padding: 15px 30px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
        .nav-bar { display: flex; gap: 15px; }
        .nav-button { padding: 8px 15px; border: 1px solid #61dafb; color: #61dafb; background-color: transparent; text-decoration: none; border-radius: 5px; cursor: pointer; font-size: 1rem; transition: background-color 0.2s, color 0.2s; }
        .nav-button:hover { background-color: #4a4f5a; }
        .nav-button.active { background-color: #61dafb; color: #20232a; font-weight: bold; }
        .title-block { text-align: center; }
        .title-block h1 { margin: 0 0 5px 0; font-size: 2.2rem; }
        .title-block p { margin: 0; font-size: 1rem; color: #ccc; }
        .cache-info-block { display: flex; flex-direction: column; align-items: flex-end; gap: 5px; width: 235px; /* Match nav-bar width */ }
        .cache-line { display: flex; align-items: center; width: 100%; gap: 8px; font-size: 0.9rem; cursor: pointer; }
        .cache-line input[type="checkbox"] { flex-shrink: 0; }
        .cache-label-text { flex-grow: 1; text-align: left; color: #ccc; }
        .cache-value { font-weight: bold; min-width: 70px; text-align: right; color: white; }
        #clearCacheBtn { margin-top: 5px; padding: 6px 12px; font-size: 0.9rem; background-color: #ff6b6b; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #clearCacheBtn:hover:not(:disabled) { background-color: #e05252; } /* Only hover if not disabled */
        #clearCacheBtn:disabled { background-color: #555; color: #888; cursor: not-allowed; } /* Style for disabled state */

        /* --- Page-Specific Content --- */
        .page-content { display: flex; flex-grow: 1; padding: 20px; gap: 20px; box-sizing: border-box; min-height: 0; }
        .sidebar { flex: 0 0 350px; background-color: #3c4049; padding: 20px; border-radius: 8px; display: flex; flex-direction: column; gap: 25px; overflow-y: auto; }
        .sidebar h2 { margin-top: 0; border-bottom: 1px solid #61dafb; padding-bottom: 10px; color: #61dafb; }
        .control-group { display: flex; flex-direction: column; gap: 10px; }
        .control-group label { font-weight: bold; font-size: 0.9rem; }
        /* Highlight for Task Selection */
        #taskControlGroup {
            background-color: #31353c; /* A slightly lighter background than sidebar */
            border: 1px solid #61dafb; /* Accent border color */
            padding: 15px; /* Increase padding for visual separation */
            border-radius: 8px; /* Match other rounded elements */
            margin-bottom: 10px; /* Add some space below it */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
        }
        #taskControlGroup label {
            color: #61dafb; /* Make the label text match the accent color */
        }
        .main-content { flex-grow: 1; display: flex; flex-direction: column; gap: 20px; min-width: 0; }
        .actions-bar { display: flex; align-items: center; gap: 20px; background-color: #4a4f5a; padding: 15px; border-radius: 8px; flex-shrink: 0; }
        #processImageBtn { font-size: 1.1rem; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; background-color: #61dafb; color: #20232a; font-weight: bold; transition: background-color 0.2s; }
        #processImageBtn:hover:not(:disabled) { background-color: #52b8d8; }
        #processImageBtn:disabled { background-color: #555; color: #888; cursor: not-allowed; }
        #status { font-style: italic; color: #ccc; }
        #status.error { color: #ff6b6b; font-weight: bold; }
        .image-feeds-container { display: flex; gap: 20px; flex-grow: 1; min-height: 0; }
        .image-box { flex: 1; background-color: #4a4f5a; border-radius: 8px; padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 15px; min-width: 0; }
        .image-header { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .image-header h3 { margin: 0; color: #61dafb; }
        .image-header button, .image-header a { font-size: 0.9rem; padding: 8px 12px; border-radius: 5px; border: none; background-color: #61dafb; color: #20232a; font-weight: bold; cursor: pointer; text-decoration: none; }
        .image-player-wrapper { width: 100%; height: 100%; background-color: #20232a; border-radius: 5px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .upload-area { border: 2px dashed #ccc; border-radius: 5px; padding: 20px; text-align: center; cursor: pointer; width: 80%; }
        .image-display { max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 5px; border: 2px solid #ccc; background-color: #20232a; box-sizing: border-box; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <header>
        <div class="nav-bar">
            <a href="wstest_uformer.html" class="nav-button">Live Stream</a>
            <a href="video_processor.html" class="nav-button">Video File</a>
            <a href="image_processor.html" class="nav-button active">Image File</a>
        </div>
        <div class="title-block">
            <h1>ðŸ¦‰ NocturaVision <span style="font-weight: 300; color: #ccc;">| Uformer</span></h1>
            <p>Image File Enhancement</p>
        </div>
        <div class="cache-info-block">
            <label class="cache-line">
                <input type="checkbox" id="clearImagesCheck" checked>
                <span class="cache-label-text">Image Cache:</span>
                <span class="cache-value" id="imageCacheValue">... MB</span>
            </label>
            <label class="cache-line">
                <input type="checkbox" id="clearVideosCheck" unchecked>
                <span class="cache-label-text">Video Cache:</span>
                <span class="cache-value" id="videoCacheValue">... MB</span>
            </label>
            <button id="clearCacheBtn">Clear Selected</button>
        </div>
    </header>
    <div class="page-content">
        <div class="sidebar">
            <h2>Image Controls</h2>
            <div class="control-group" id="taskControlGroup">
                <label for="taskSelect">Task</label>
                <select id="taskSelect" style="padding: 8px; font-size: 1rem; border-radius: 4px; border: 1px solid #61dafb; background-color: #4a4f5a; color: white;">
                    <option value="denoise">Denoise</option>
                    <option value="deblur">Deblur</option>
                </select>
            </div>
            <div class="control-group">
                <label for="modelSelect">Enhancement Model</label>
                <select id="modelSelect" style="padding: 8px; font-size: 1rem; border-radius: 4px; border: 1px solid #61dafb; background-color: #4a4f5a; color: white;">
                    <!-- Options will be dynamically populated by JavaScript -->
                </select>
            </div>
            <div class="control-group checkbox-group">
                <label><input type="checkbox" id="patchCheckbox" checked> Use Patch Processing (High Quality)</label>
            </div>
            <!-- Any future image-specific controls can go here -->
        </div>
        <div class="main-content">
            <div class="actions-bar">
                <button id="processImageBtn" disabled>Process Image</button>
                <p id="status">Please select an image file. Supports: jpeg, png, gif, webp, .arw.</p>
            </div>
            <div class="image-feeds-container">
                <div class="image-box">
                    <div class="image-header">
                        <h3>Original Image</h3>
                        <input type="file" id="imageUpload" accept="image/jpeg,image/png,image/gif,image/webp,.arw" style="display: none;">
                        <button id="selectImageBtn">Select Image</button>
                    </div>
                    <div id="original-image-wrapper" class="image-player-wrapper">
                        <div id="upload-area" class="upload-area">
                            <p>Drag & Drop an image file here or click this area</p>
                            <p style="font-size: 0.8rem; color: #ccc;">(Supports: JPG, PNG, ARW, etc.)</p>
                        </div>
                        <img id="originalImage" class="image-display hidden" alt="Original Image">
                    </div>
                </div>
                <div class="image-box">
                    <div class="image-header">
                        <h3>Enhanced Image</h3>
                        <a id="downloadBtn" href="#" class="hidden" download>Download</a>
                    </div>
                    <div id="processed-image-wrapper" class="image-player-wrapper">
                        <img id="processedImage" class="image-display hidden" alt="Processed Image">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // DOM Elements
        const selectImageBtn = document.getElementById('selectImageBtn');
        const imageUploadInput = document.getElementById('imageUpload');
        const uploadArea = document.getElementById('upload-area');
        const originalImage = document.getElementById('originalImage');
        const processedImage = document.getElementById('processedImage');
        const processImageBtn = document.getElementById('processImageBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const statusSpan = document.getElementById('status');
        const taskSelect = document.getElementById('taskSelect');
        const modelSelect = document.getElementById('modelSelect');
        const patchCheckbox = document.getElementById('patchCheckbox');
        // --- Cache Management ---
        const clearCacheBtn = document.getElementById('clearCacheBtn');
        const clearImagesCheck = document.getElementById('clearImagesCheck');
        const clearVideosCheck = document.getElementById('clearVideosCheck');
        const imageCacheValue = document.getElementById('imageCacheValue');
        const videoCacheValue = document.getElementById('videoCacheValue');

        let selectedImageFile = null;

        // --- Event Listeners ---
        selectImageBtn.onclick = () => imageUploadInput.click();
        imageUploadInput.onchange = (event) => handleImageFile(event.target.files[0]);

        uploadArea.ondragover = (event) => { event.preventDefault(); uploadArea.style.borderColor = '#61dafb'; };
        uploadArea.ondragleave = (event) => { event.preventDefault(); uploadArea.style.borderColor = '#ccc'; };
        uploadArea.ondrop = (event) => {
            event.preventDefault();
            uploadArea.style.borderColor = '#ccc';
            if (event.dataTransfer.files && event.dataTransfer.files[0]) {
                handleImageFile(event.dataTransfer.files[0]);
            }
        };
        uploadArea.onclick = () => imageUploadInput.click();

        processImageBtn.onclick = async () => {
            if (!selectedImageFile) {
                statusSpan.textContent = "Error: No image selected.";
                statusSpan.classList.add('error');
                return;
            }

            statusSpan.textContent = `Processing "${selectedImageFile.name}"...`;
            statusSpan.classList.remove('error');
            processImageBtn.disabled = true;
            downloadBtn.classList.add('hidden');
            processedImage.classList.add('hidden');

            const formData = new FormData();
            formData.append("image_file", selectedImageFile);
            formData.append("task_type", taskSelect.value); // Add task type
            formData.append("model_name", modelSelect.value);
            formData.append("use_patch_processing", patchCheckbox.checked);

            try {
                // Endpoint to be created in the next step
                const response = await fetch('http://127.0.0.1:8000/api/process_image', { 
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: 'Server returned an unreadable error.' }));
                    throw new Error(errorData.detail || `Server responded with status ${response.status}`);
                }
                
                const blob = await response.blob(); // Get the response as a Blob
                const imageUrl = URL.createObjectURL(blob); // Create a URL for the Blob

                processedImage.src = imageUrl;
                processedImage.classList.remove('hidden');
                downloadBtn.href = imageUrl;
                const taskType = taskSelect.value;
                downloadBtn.download = `enhanced_${taskType}_${selectedImageFile.name}`; // Set download filename with task type
                downloadBtn.classList.remove('hidden');

                await updateCacheStatus(); // Update cache info after processing
                statusSpan.textContent = "Image processing complete!";

            } catch (error) {
                statusSpan.classList.add('error');
                statusSpan.textContent = `Error: ${error.message}. Is the backend running?`;
            } finally {
                processImageBtn.disabled = false;
            }
        };
        
        // --- Helper Functions ---
        async function handleImageFile(file) {
            if (!file) return;

            selectedImageFile = file;
            const isRaw = file.name.toLowerCase().endsWith('.arw');

            originalImage.classList.remove('hidden');
            uploadArea.classList.add('hidden');
            statusSpan.textContent = `Loading preview for "${file.name}"...`;
            statusSpan.classList.remove('error');
            originalImage.src = ""; // Clear previous image

            try {
                let previewUrl;
                if (isRaw) {
                    // For RAW files, we must ask the server to generate a JPG preview
                    const formData = new FormData();
                    formData.append("image_file", file);
                    const response = await fetch('http://127.0.0.1:8000/api/generate_preview', {
                        method: 'POST',
                        body: formData
                    });
                    if (!response.ok) throw new Error('Server could not generate preview.');
                    const blob = await response.blob();
                    previewUrl = URL.createObjectURL(blob);
                } else {
                    // For standard images, the browser can display them directly
                    previewUrl = URL.createObjectURL(file);
                }
                originalImage.src = previewUrl;
                statusSpan.textContent = `Selected: "${file.name}". Ready to process.`;
                processImageBtn.disabled = false;

            } catch (error) {
                console.error("Preview Error:", error);
                statusSpan.textContent = `Error: Could not load preview for "${file.name}".`;
                statusSpan.classList.add('error');
                originalImage.classList.add('hidden');
                uploadArea.classList.remove('hidden');
                processImageBtn.disabled = true;
            }

            // Reset the processed side
            processedImage.src = "";
            processedImage.classList.add('hidden');
            downloadBtn.classList.add('hidden');
        }

        // --- Cache Management ---
        async function updateCacheStatus() {
            try {
                const response = await fetch('http://127.0.0.1:8000/api/cache_status');
                if (!response.ok) throw new Error("Server status check failed");
                const data = await response.json();
                imageCacheValue.textContent = `${data.image_cache_mb} MB`;
                videoCacheValue.textContent = `${data.video_cache_mb} MB`;
            } catch (error) {
                console.error("Failed to fetch cache status:", error);
                imageCacheValue.textContent = `Error`;
                videoCacheValue.textContent = `Error`;
            }
        }

        function toggleClearButtonState() {
            if (!clearImagesCheck.checked && !clearVideosCheck.checked) {
                clearCacheBtn.disabled = true;
            } else {
                clearCacheBtn.disabled = false;
            }
        }
        
        clearImagesCheck.addEventListener('change', toggleClearButtonState);
        clearVideosCheck.addEventListener('change', toggleClearButtonState);
        
        clearCacheBtn.onclick = async () => {
            const clearImages = clearImagesCheck.checked;
            const clearVideos = clearVideosCheck.checked;
            
            const confirmationMessage = `Are you sure you want to clear the selected cache(s)?`;
            if (!confirm(confirmationMessage)) {
                return;
            }

            try {
                const url = new URL('http://127.0.0.1:8000/api/clear_cache');
                url.searchParams.append('clear_images', clearImages);
                url.searchParams.append('clear_videos', clearVideos);

                const response = await fetch(url, { method: 'POST' });
                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.detail || 'Failed to clear cache.');
                }
                
                alert(result.message || 'Cache cleared successfully!');
                await updateCacheStatus();
            } catch (error) {
                console.error("Cache clear error:", error);
                alert(`An error occurred: ${error.message}`);
            }
        };

        // --- Model and Task Management ---
        const modelsByTask = {
            denoise: [
                { value: 'denoise_b', text: 'Uformer-B (High Quality)' },
                { value: 'denoise_16', text: 'Uformer-16 (Fast)' }
            ],
            deblur: [
                { value: 'deblur_b', text: 'Uformer-B (Deblur)' }
            ]
        };

        function populateModelSelect(taskType) {
            modelSelect.innerHTML = ''; // Clear existing options
            const models = modelsByTask[taskType];
            if (models) {
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.value;
                    option.textContent = model.text;
                    
                    // Set 'Uformer-16 (Fast)' as default for 'denoise' task, or select the only option available
                    if (taskType === 'denoise' && model.value === 'denoise_16') {
                        option.selected = true;
                    } else if (models.length === 1) { // If there's only one model for a task, select it
                        option.selected = true;
                    }

                    modelSelect.appendChild(option);
                });
            }
        }

        // Event listener for task selection change
        taskSelect.addEventListener('change', (event) => {
            populateModelSelect(event.target.value);
        });

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            updateCacheStatus();
            toggleClearButtonState(); // Set initial button state on page load
            populateModelSelect(taskSelect.value); // Populate models based on initial task selection
        });
    </script>
</body>
</html>
