<!-- noctura-uformer/backend/wstest_uformer.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NocturaVision - Live Stream</title>
    <style>
        html, body { height: 100vh; margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #282c34; color: white; display: flex; flex-direction: column; }
        
        /* --- Consistent Header --- */
        header { background-color: #20232a; padding: 15px 30px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
        .nav-bar { display: flex; gap: 15px; }
        .nav-button { padding: 8px 15px; border: 1px solid #61dafb; color: #61dafb; background-color: transparent; text-decoration: none; border-radius: 5px; cursor: pointer; font-size: 1rem; transition: background-color 0.2s, color 0.2s; }
        .nav-button:hover { background-color: #4a4f5a; }
        .nav-button.active { background-color: #61dafb; color: #20232a; font-weight: bold; }
        .title-block { text-align: center; }
        .title-block h1 { margin: 0 0 5px 0; font-size: 2.2rem; }
        .title-block p { margin: 0; font-size: 1rem; color: #ccc; }
        
        /* --- Replicated Two-Column Header Controls --- */
        .controls-container { display: flex; flex-direction: row; gap: 20px; align-items: stretch; }
        .control-column { display: flex; flex-direction: column; }
        .cache-line { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; cursor: pointer; }
        .cache-label-text { flex-grow: 1; text-align: left; color: #ccc; }
        .cache-value { font-weight: bold; min-width: 70px; text-align: right; color: white; }
        #vramManagerBlock { display: none; /* Hidden by default, enabled by JS */ }
        #loadedModelsList { margin-bottom: 5px; max-height: 80px; overflow-y: auto; width: 100%; }
        #clearCacheBtn { padding: 6px 12px; font-size: 0.9rem; background-color: #ff6b6b; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #clearCacheBtn:hover:not(:disabled) { background-color: #e05252; border-color: #d04242; }
        
        /* VRAM Buttons Styling */
        .vram-button { padding: 6px 10px; font-size: 0.85rem; border: none; border-radius: 5px; cursor: pointer; transition: filter 0.2s; }
        #clearSelectedModelsBtn { background-color: #f0e68c; color: #333; }
        #clearAllModelsBtn { background-color: #61dafb; color: #20232a; }
        .vram-button:hover:not(:disabled) { filter: brightness(0.9); }
        .button-row { display: flex; justify-content: space-between; width: 100%; }
        
        /* Generic Disabled Styles for ALL Buttons */
        button:disabled { background-color: #555 !important; color: #888 !important; cursor: not-allowed !important; filter: none !important; }

        /* --- Page-Specific Content --- */
        .page-content { display: flex; flex-grow: 1; padding: 20px; gap: 20px; box-sizing: border-box; min-height: 0; }
        .sidebar { flex: 0 0 350px; background-color: #3c4049; padding: 20px; border-radius: 8px; display: flex; flex-direction: column; gap: 25px; overflow-y: auto; }
        .sidebar h2 { margin-top: 0; border-bottom: 1px solid #61dafb; padding-bottom: 10px; color: #61dafb; }
        .control-group { display: flex; flex-direction: column; gap: 10px; }
        .control-group label { font-weight: bold; font-size: 0.9rem; }
        .checkbox-group label { display: flex; align-items: center; gap: 10px; cursor: pointer; }
        .main-content { flex-grow: 1; display: flex; flex-direction: column; gap: 20px; min-width: 0; }
        .actions-bar { display: flex; align-items: center; gap: 20px; background-color: #4a4f5a; padding: 15px; border-radius: 8px; flex-shrink: 0; }
        #startButton, #stopButton { font-size: 1.1rem; padding: 10px 20px; cursor: pointer; border: none; border-radius: 5px; background-color: #61dafb; color: #20232a; font-weight: bold; transition: background-color 0.2s; }
        #startButton:hover:not(:disabled), #stopButton:hover:not(:disabled) { background-color: #52b8d8; }
        #status { font-style: italic; color: #ccc; }
        #status.error { color: #ff6b6b; font-weight: bold; }
        .video-feeds-container { display: flex; gap: 20px; flex-grow: 1; min-height: 0; }
        .video-box { flex: 1; background-color: #4a4f5a; border-radius: 8px; padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; min-width: 0; }
        .video-box h3 { margin: 0; color: #61dafb; flex-shrink: 0; }
        .video-box video, .video-box img { width: 100%; height: 100%; max-height: 100%; border-radius: 5px; border: 2px solid #ccc; background-color: #20232a; aspect-ratio: 4 / 3; object-fit: contain; box-sizing: border-box; }
        
        /* Apply mirror effect to both video feeds for a consistent user experience */
        #webcam, #processedImage { transform: scaleX(-1); }
    </style>
</head>
<body>
    <header>
        <div class="nav-bar">
            <a href="wstest_uformer.html" class="nav-button active">Live Stream</a>
            <a href="video_processor.html" class="nav-button">Video File</a>
            <a href="image_processor.html" class="nav-button">Image File</a>
        </div>
        <div class="title-block">
            <h1>ðŸ¦‰ NocturaVision <span style="font-weight: 300; color: #ccc;">| Uformer</span></h1>
            <p>Real-time Enhancement</p>
        </div>
        <div class="controls-container">
            <!-- Left Column: Cache Manager -->
            <div class="control-column" style="min-width: 150px;">
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <label class="cache-line">
                        <input type="checkbox" id="clearImagesCheck">
                        <span class="cache-label-text">Image Cache:</span>
                        <span class="cache-value" id="imageCacheValue">... MB</span>
                    </label>
                    <label class="cache-line">
                        <input type="checkbox" id="clearVideosCheck">
                        <span class="cache-label-text">Video Cache:</span>
                        <span class="cache-value" id="videoCacheValue">... MB</span>
                    </label>
                </div>
                <div style="display: flex; justify-content: center; width: 100%; margin-top: auto; padding-top: 5px;">
                    <button id="clearCacheBtn">Clear Selected Cache</button>
                </div>
            </div>
            <!-- Right Column: VRAM Manager -->
            <div class="control-column" id="vramManagerBlock" style="min-width: 200px;">
                 <div id="loadedModelsList"></div>
                 <div class="button-row">
                    <button id="clearSelectedModelsBtn" class="vram-button">Clear Selected</button>
                    <button id="clearAllModelsBtn" class="vram-button">Clear All</button>
                 </div>
            </div>
        </div>
    </header>
    <div class="page-content">
        <div class="sidebar">
            <h2>Live Controls</h2>
            <div class="control-group" id="taskControlGroup" style="background-color: #31353c; border: 1px solid #61dafb; padding: 15px; border-radius: 8px; margin-bottom: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);">
                <label for="taskSelect" style="color: #61dafb;">Task</label>
                <select id="taskSelect" style="padding: 8px; font-size: 1rem; border-radius: 4px; border: 1px solid #61dafb; background-color: #4a4f5a; color: white;">
                    <option value="denoise">Denoise</option>
                    <option value="deblur">Deblur</option>
                </select>
            </div>
            <div class="control-group">
                <label for="modelSelect">Enhancement Model</label>
                <select id="modelSelect" style="padding: 8px; font-size: 1rem; border-radius: 4px; border: 1px solid #61dafb; background-color: #4a4f5a; color: white;"></select>
            </div>
            <div class="control-group checkbox-group">
                <label><input type="checkbox" id="fpsCheckbox" checked> Show FPS Counter</label>
            </div>
            <div class="control-group checkbox-group">
                <label>
                    <input type="checkbox" id="patchCheckbox"> Use Patch Processing
                    <span id="patchWarning" style="color: #ff6b6b; font-weight: bold; display: none;"> (Not Recommended: Very Slow)</span>
                </label>
            </div>
        </div>
        <div class="main-content">
            <div class="actions-bar">
                <button id="startButton">Start Webcam</button>
                <button id="stopButton" disabled>Stop Webcam</button>
                <p id="status">Idle. Press Start to begin.</p>
            </div>
            <div class="video-feeds-container">
                <div class="video-box">
                    <h3>Original Webcam</h3>
                    <video id="webcam" autoplay playsinline muted></video>
                </div>
                <div class="video-box">
                    <h3>Enhanced Stream</h3>
                    <img id="processedImage" alt="Processed stream from backend" />
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element References ---
            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            const webcamVideo = document.getElementById('webcam');
            const processedImage = document.getElementById('processedImage');
            const statusSpan = document.getElementById('status');
            const taskSelect = document.getElementById('taskSelect');
            const modelSelect = document.getElementById('modelSelect');
            const fpsCheckbox = document.getElementById('fpsCheckbox');
            const patchCheckbox = document.getElementById('patchCheckbox');
            const patchWarning = document.getElementById('patchWarning');
            
            // --- Cache Management Elements ---
            const clearCacheBtn = document.getElementById('clearCacheBtn');
            const clearImagesCheck = document.getElementById('clearImagesCheck');
            const clearVideosCheck = document.getElementById('clearVideosCheck');
            const imageCacheValue = document.getElementById('imageCacheValue');
            const videoCacheValue = document.getElementById('videoCacheValue');
            
            // --- VRAM Management Elements ---
            const vramManagerBlock = document.getElementById('vramManagerBlock');
            const loadedModelsList = document.getElementById('loadedModelsList');
            const clearSelectedModelsBtn = document.getElementById('clearSelectedModelsBtn');
            const clearAllModelsBtn = document.getElementById('clearAllModelsBtn');

            // --- State Variables ---
            let websocket;
            let stream;
            let isStreaming = false;
            let modelStatusInterval = null;
            let selectedModelsToClear = new Set();
            const WS_URL = "ws://127.0.0.1:8000/ws/process_video";

            // --- Live Stream Logic ---
            const stopStreaming = () => {
                if (modelStatusInterval) {
                    clearInterval(modelStatusInterval);
                    modelStatusInterval = null;
                }
                isStreaming = false;
                if (websocket) {
                    websocket.onclose = null; 
                    websocket.close();
                }
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    webcamVideo.srcObject = null;
                }
                startButton.disabled = false;
                stopButton.disabled = true;
                processedImage.src = "";
                updateLoadedModelsStatus(); // Final status update
            };

            const processAndSendFrame = () => {
                if (!isStreaming || !websocket || websocket.readyState !== WebSocket.OPEN) return;
                if (!webcamVideo.videoWidth || !webcamVideo.videoHeight) {
                    requestAnimationFrame(processAndSendFrame);
                    return;
                }
                const canvas = document.createElement('canvas');
                canvas.width = webcamVideo.videoWidth;
                canvas.height = webcamVideo.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(webcamVideo, 0, 0, canvas.width, canvas.height);
                const dataUrl = canvas.toDataURL('image/jpeg');
                const payload = {
                    image_b64: dataUrl, task_type: taskSelect.value, model_name: modelSelect.value,
                    show_fps: fpsCheckbox.checked, use_patch_processing: patchCheckbox.checked
                };
                websocket.send(JSON.stringify(payload));
            };

            startButton.onclick = async () => {
                try {
                    statusSpan.classList.remove('error');
                    stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    webcamVideo.srcObject = stream;
                    statusSpan.textContent = 'Webcam started.';
                    websocket = new WebSocket(WS_URL);
                    websocket.onopen = () => {
                        statusSpan.textContent = 'WebSocket Connected. Processing...';
                        startButton.disabled = true;
                        stopButton.disabled = false;
                        isStreaming = true;
                        requestAnimationFrame(processAndSendFrame);
                        if (modelStatusInterval) clearInterval(modelStatusInterval);
                        modelStatusInterval = setInterval(updateLoadedModelsStatus, 2000);
                    };
                    websocket.onmessage = (event) => {
                        processedImage.src = event.data;
                        if (isStreaming) requestAnimationFrame(processAndSendFrame);
                    };
                    websocket.onclose = () => {
                        if (isStreaming) statusSpan.textContent = 'WebSocket Disconnected.';
                        stopStreaming();
                    };
                    websocket.onerror = () => {
                        statusSpan.classList.add('error');
                        statusSpan.textContent = !isStreaming ? 'Connection Failed. Is the backend running?' : 'WebSocket Error during stream.';
                        stopStreaming();
                    };
                } catch (err) {
                    statusSpan.textContent = 'Error starting webcam!';
                }
            };
            stopButton.onclick = () => {
                statusSpan.classList.remove('error');
                statusSpan.textContent = 'Idle. Press Start to begin.';
                stopStreaming();
            };

            // --- VRAM Management Logic ---
            const checkModelLoadingStrategy = async () => {
                try {
                    const response = await fetch('http://127.0.0.1:8000/api/model_loading_strategy');
                    const data = await response.json();
                    if (!data.load_all_on_startup) {
                        vramManagerBlock.style.display = 'flex';
                        updateLoadedModelsStatus();
                    }
                } catch (error) {
                    console.error("Could not fetch model loading strategy:", error);
                }
            };
            
            const renderLoadedModels = (models) => {
                loadedModelsList.innerHTML = '';
                let anyModelLoaded = false;
                models.forEach(model => {
                    if (model.loaded) anyModelLoaded = true;
                    if (!model.loaded && selectedModelsToClear.has(model.name)) {
                        selectedModelsToClear.delete(model.name);
                    }
                    const isChecked = selectedModelsToClear.has(model.name);
                    const label = document.createElement('label');
                    label.className = 'cache-line';
                    label.style.fontSize = '0.85rem';
                    label.innerHTML = `
                        <input type="checkbox" ${model.loaded ? '' : 'disabled'} ${isChecked ? 'checked' : ''} data-model-name="${model.name}">
                        <span class="cache-label-text" style="margin-left: 8px;">${model.name}</span>
                        <span style="color: ${model.loaded ? '#86e58b' : '#ff7a7a'}; font-weight: bold; min-width: 65px; text-align: right; margin-left: auto;">
                            ${model.loaded ? 'Loaded' : 'Unloaded'}
                        </span>`;
                    label.querySelector('input').onchange = (e) => {
                        const name = e.target.dataset.modelName;
                        if (e.target.checked) selectedModelsToClear.add(name);
                        else selectedModelsToClear.delete(name);
                        toggleVramButtons();
                    };
                    loadedModelsList.appendChild(label);
                });
                clearAllModelsBtn.disabled = !anyModelLoaded;
                toggleVramButtons();
            };

            const updateLoadedModelsStatus = async () => {
                try {
                    const response = await fetch('http://127.0.0.1:8000/api/loaded_models_status');
                    const data = await response.json();
                    renderLoadedModels(data.models || []);
                } catch (error) {
                    console.error("Failed to fetch loaded models status:", error);
                }
            };

            const toggleVramButtons = () => {
                clearSelectedModelsBtn.disabled = selectedModelsToClear.size === 0;
            };

            const handleClearModels = async (modelsToClear = []) => {
                const isClearingAll = modelsToClear.length === 0;
                const modelListStr = Array.from(modelsToClear).join(', ');
                const confirmMsg = isClearingAll ? "Unload ALL models?" : `Unload ${modelListStr}?`;
                if (!confirm(confirmMsg)) return;
                try {
                    const response = await fetch('http://127.0.0.1:8000/api/unload_models', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ model_names: modelsToClear })
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.detail);
                    alert(result.message);
                    await updateLoadedModelsStatus();
                } catch (error) {
                    alert(`Error unloading models: ${error.message}`);
                }
            };
            clearSelectedModelsBtn.onclick = () => handleClearModels(Array.from(selectedModelsToClear));
            clearAllModelsBtn.onclick = () => handleClearModels([]);

            // --- Cache Management Logic ---
            const updateCacheStatus = async () => {
                try {
                    const response = await fetch('http://127.0.0.1:8000/api/cache_status');
                    const data = await response.json();
                    imageCacheValue.textContent = `${data.image_cache_mb} MB`;
                    videoCacheValue.textContent = `${data.video_cache_mb} MB`;
                } catch (error) {
                    imageCacheValue.textContent = `Error`; videoCacheValue.textContent = `Error`;
                }
            };
            const toggleClearCacheButtonState = () => {
                clearCacheBtn.disabled = !clearImagesCheck.checked && !clearVideosCheck.checked;
            };
            clearImagesCheck.addEventListener('change', toggleClearCacheButtonState);
            clearVideosCheck.addEventListener('change', toggleClearCacheButtonState);
            clearCacheBtn.onclick = async () => {
                if (!confirm(`Are you sure you want to clear the selected cache(s)?`)) return;
                try {
                    const url = new URL('http://127.0.0.1:8000/api/clear_cache');
                    url.searchParams.append('clear_images', clearImagesCheck.checked);
                    url.searchParams.append('clear_videos', clearVideosCheck.checked);
                    const response = await fetch(url, { method: 'POST' });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.detail);
                    alert(result.message);
                    clearImagesCheck.checked = false;
                    clearVideosCheck.checked = false;
                    toggleClearCacheButtonState();
                    await updateCacheStatus();
                } catch (error) {
                    alert(`An error occurred: ${error.message}`);
                }
            };

            // --- Model and Task Management ---
            const modelsByTask = {
                denoise: [{ value: 'denoise_b', text: 'Uformer-B (High Quality)' }, { value: 'denoise_16', text: 'Uformer-16 (Fast)' }],
                deblur: [{ value: 'deblur_b', text: 'Uformer-B (Deblur)' }]
            };
            const populateModelSelect = (taskType) => {
                modelSelect.innerHTML = '';
                const models = modelsByTask[taskType];
                if (models) {
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.value;
                        option.textContent = model.text;
                        if (taskType === 'denoise' && model.value === 'denoise_16') option.selected = true;
                        else if (models.length === 1) option.selected = true;
                        modelSelect.appendChild(option);
                    });
                }
            };
            taskSelect.addEventListener('change', (e) => populateModelSelect(e.target.value));
            patchCheckbox.onchange = () => { patchWarning.style.display = patchCheckbox.checked ? 'inline' : 'none'; };

            // --- Initial Page Load ---
            updateCacheStatus();
            toggleClearCacheButtonState();
            populateModelSelect(taskSelect.value);
            checkModelLoadingStrategy();
        });
    </script>
</body>
</html>
