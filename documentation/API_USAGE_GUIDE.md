<!-- documentation/API_USAGE_GUIDE.md -->  
# Uformer FastAPI Hub: API Usage Guide

**Document Version:** 1.0
**Date:** 2024-08-01

Welcome to the Uformer FastAPI Hub API. This guide provides instructions for third-party developers on how to integrate our powerful image and video enhancement services into their own applications.

---

## 1. Introduction & Core Concepts

The API provides endpoints for real-time and asynchronous file-based enhancement of images and videos using state-of-the-art Uformer models.

### 1.1. Asynchronous by Design

All file processing operations (for images and videos) are **asynchronous**. This means you will not receive the processed file in the same request you use to upload it. Instead, you will receive a `task_id` and must poll a status endpoint to get the result. This non-blocking pattern is designed for handling long-running tasks without tying up connections.

### 1.2. Interactive API Documentation

A complete, interactive specification of every available endpoint, including all required parameters, request bodies, and response models, is automatically generated by the server.

*   **Swagger UI (Recommended):** [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)
*   **ReDoc:** [http://127.0.0.1:8000/redoc](http://127.0.0.1:8000/redoc)

**Please refer to the `/docs` endpoint for all low-level details.** This guide will focus on the high-level workflow.

---

## 2. General Workflow for File Processing

This "Start-and-Poll" workflow applies to both the image and video processors.

### Step 1: Start the Processing Task

To begin, send a `POST` request with `multipart/form-data` to the appropriate endpoint:
*   **Image Processing:** `/api/process_image`
*   **Video Processing:** `/api/process_video`

**Request Body:**

| Parameter              | Type       | Description                                                                 |
| ---------------------- | ---------- | --------------------------------------------------------------------------- |
| `image_file` or `video_file` | `File`     | The image or video file to be processed.                                    |
| `task_type`            | `str`      | The task to perform. Currently `'denoise'` or `'deblur'`.                 |
| `model_name`           | `str`      | The specific model to use (e.g., `'denoise_16'`, `'deblur_b'`).           |
| `use_patch_processing` | `bool`     | (Image Only) `true` for high-quality patch-based processing (recommended). |

**Successful Response (`202 Accepted`):**

If the request is valid, the server will accept the task and immediately respond with a JSON object containing the `task_id`.

```json
{
  "task_id": "a1b2c3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "message": "Image processing task started."
}
```

Store this `task_id` immediately. You will need it for the next step.

### Step 2: Poll for Task Status

Once you have a `task_id`, begin polling the relevant status endpoint with a `GET` request every 2-5 seconds.

*   **Image Status:** `/api/image_status/{task_id}`
*   **Video Status:** `/api/video_status/{task_id}`

The response will be a JSON object detailing the task's current state.

**Example Response (while processing):**

```json
{
  "status": "processing",
  "progress": 42,
  "message": "Processing..."
}
```

**Example Response (on failure):**
```json
{
  "status": "failed",
  "error": "An error message describing the failure."
}
```

Continue polling as long as the `status` is `'pending'` or `'processing'`.

### Step 3: Retrieve the Result

When the status poll returns a `completed` status, the polling should stop. The response object will now contain a `result_path`.

**Example Response (on completion):**

```json
{
  "status": "completed",
  "result_path": "/static_results/images/denoise/processed/1678886400_a1b2c3d4_enhanced_image.jpg"
}
```

This `result_path` is a server-relative URL. To create the full, downloadable URL, you must prepend the API's base address.

**Constructing the Final URL:**

`[API_BASE_URL]` + `[result_path]`

**Example:**
`http://127.0.0.1:8000` + `/static_results/images/denoise/processed/1678886400_a1b2c3d4_enhanced_image.jpg`

This final URL can be used as the `src` for an `<img>` tag or as the target for a download link.

---

## 3. Optional: Cache Management & Resource Tracking

For advanced clients that allow users to manage server resources, the API provides several endpoints.

### 3.1. Confirming a Download

To participate in the server's automated cache cleanup, it is highly recommended to confirm when a user has initiated a download.

**Endpoint:** `POST /api/confirm_download`

**Request Body (`application/json`):**
```json
{
  "result_path": "/static_results/images/..."
}
```

Calling this endpoint marks the file as "downloaded" and allows the server's automated garbage collector to safely clean it up after a configured grace period.

### 3.2. Heartbeat for Active Viewing

If your application keeps a result visible on screen for a long time without downloading, you can use the heartbeat mechanism to prevent the server from flagging the file as "abandoned."

**Endpoint:** `POST /api/task_heartbeat`

**Request Body (`application/json`):**
```json
{
  "task_id": "a1b2c3d4-..."
}
```

Call this endpoint periodically (e.g., every 5 minutes) for any result file that is being actively viewed. Stop calling it once the user navigates away or downloads the file.

---
For all other endpoints, including VRAM management and manual cache clearing, please consult the interactive `/docs` page on the running server.
